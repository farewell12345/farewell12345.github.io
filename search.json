[{"title":"learn shell(updating....)","url":"/2022/05/02/learn-shell/","content":"\n\n\n# First-Shell-Script\n\n```shell\necho \"hello world\" # Anyway, you can writing another string , like `echo \"fuck shell\"` \n```\n\n<!--more-->\n\nIn Linux , create new file `test.sh`,  using vim to edit `test.sh`, coding first shell script. And use `chmod +x test.sh`  give run permissions.\n\nThen, run `./test.sh` , like this:\n\n![](https://s2.loli.net/2022/05/02/nuam1wI2xZiAbBq.png)\n\n# Shell-Variable\n\nYou can create variable in shell,  example:\n\n```shell\nvariable_str=\"variable\"\nvariable_int=123\nvariable_float=1.2\necho -e \"str:${variable_str} \\n int:${variable_int} \\n float:${variable_float}\"\n# if you want to use escape character, like `\\n`、`\\t` and so on , you should use `echo -e` to print it, \n# if not, the string '\\n' is printed instead of a newline character . \n```\n\nrun `./test.sh`, like this:\n\n![](https://s2.loli.net/2022/05/02/8RZapXBnEzd3Nyx.png)\n\n# String\n\n```shell\nstring=\"fuck shell\"\necho $string\n```\n\n![](https://s2.loli.net/2022/05/03/GkHsAYL1CgelFOK.png)\n\n## Intercept-String\n\nYou can use string slice to extract the substring , example:\n\n```shell\nstring=\"fuck shell\"\necho ${string:2:4}\n```\n\n![](https://s2.loli.net/2022/05/03/gVHLW639kJKjO2B.png)\n\n","tags":["shell"]},{"title":"一个简易开放平台（RPC）的设计思路","url":"/2022/04/20/一个简易开放平台的设计思路/","content":"\n# 起因\n\n​\t\t去年7月打计算机程序设计大赛的时候设计了一套互联网虚假信息监测开放平台，本来想着打完比赛就写篇博客，结果比赛越打越多，~~绝对不是我咕咕咕~~。最近投实习，暂时闲下来了，分享一下当时的一些设计思路与经验。\n\n<!--more-->\n\n# 基本构成要素\n\n一个开放平台以提供RPC（Remote Procedure Call）远程过程调用服务为主，应该包含以下要素：\n\n1. 鉴权设计（OAuth1.0、OAuth2.0）\n2. RPC服务\n\n# 平台定位\n\n​\t\t开放平台的定位大部分都是ToB的，因此需要精准定位客户需求，这里以我设计的互联网虚假信息监测开放平台为例。\n\n## 目标群体\n\n​\t\t要了解客户需求，首先要明确客户到底是哪些人。\n\n​\t\t显而易见，需要互联网虚假信息监测服务的场景集中于各类社交平台等舆论密集的地方，因此，这种社交平台的开发者和管理者就是我们的目标群体。\n\n## 痛点分析\n\n​\t\t确立了目标群体，那么就要分析这个群体最需要什么，即这个行业中存在的痛点在哪，从痛点着手切入，才能开发出好用的产品。\n\n在虚假信息监测开放平台中，目标群体的痛点就在于人力审核互联网舆论的高成本、低效率，众所周知，互联网舆论是非常庞大的，要审核起来非常费劲，但是又不能完全放弃管控，~~你永远不知道用户会搞出什么幺蛾子~~。\n\n​\t\t因此，本平台就立足于互联网人力审核成本高、效率低这一痛点上进行构建，平台的核心是监测互联网虚假信息，平台的目标，就是让社交平台的管理人员能够提高舆论审核的工作效率，降低人力成本，将他们从无尽地审核地狱里解放出来。\n\n### 结论\n\n​\t\t至此，我们就完成了第一步，开放平台的目标定位，接下来要做的，就是切入我们上面所分析出的行业痛点，进行平台的概要设计\n\n# 概要设计\n\n​\t\t在这一阶段我们需要完成整体项目的结构梳理，包括架构、功能点。\n\n## 需求分析\n\n​\t\t上面我们确立了平台需要致力于解决的痛点，那么接下来我们就需要针对痛点来推断需求，**功能为需求而服务**，因此基于关键痛点进行需求分析是非常重要的一个环节。\n\n​\t\t针对互联网舆论人力审核成本高、效率低这一痛点，我们可以拆分出多条需求。\n\n> 1. 监测多种虚假信息文本，主要包括谣言、敏感词、营销号三种\n>\n> 2. 需要提供自定义化服务，以解决不同平台有不同敏感词监测规范的情况。（~~比如在B站，你所热爱的就是你的生活~~，在B站是违禁词，但在其它地方可不一定是）\n> 3. 需要为接入的平台提供数据可视化服务，以方便用户查看各类虚假信息的趋势，更好地制定舆论管控规则\n> 4. 要有容易上手的接口设计和详细的说明文档，防止用户看完一头雾水，依然不会用\n> 5. 稳定可靠的服务支持，毫无疑问一个社交平台的信息量是非常恐怖的，因此我们的平台必须具有极高的稳定性，要能够抗住非常恐怖的流量才可以\n\n## 功能设计\n\n​\t\t有了明确的需求，就可以针对需求来设计功能了，我们从上面的五条需求展开来设计功能\n\n#### 1. 虚假信息文本监测\n\n​\t\t针对于虚假信息文本监测的需求，我们以提供RPC接口的方式为用户提供云端虚假信息监测服务，身份校验采用OAuth1.0原则（因为简单，现在应该使用2.0），通过签发令牌的方式来实现。\n\n​\t\t鉴于需要至少实现三种不同的舆论识别，也即谣言、敏感词、营销号，所以我们需要提供三套不同的RPC服务，分别就是：谣言监测、敏感词识别、营销文本分类识别。\n\n#### 2. 自定义舆论监测规则\n\n​\t\t针对部分平台需要自定义监测规则的需求来说，同样可以使用RPC接口的方式为用户提供云端服务，不同与上一点，这个功能下我们需要让用户上传自定义的文件规则。然后后台基于该数据文件，制定适合用户的识别模型。\n\n#### 3. 数据可视化服务\n\n​\t\t舆论的实时情况统计，统计用户的平台在某个时间段内的虚假信息数量，并展示给用户观看，因此需要后端实现在监测到违法信息时，对其进行一个分类统计的功能，包括在某个时间段内用户所接入平台的谣言舆论数量、带有敏感词监测的舆论数量。\n","tags":["后端"]},{"title":"LineArt-线稿API使用文档","url":"/2022/04/01/LineArt-线稿API使用文档/","content":"\n\n\n\n\n将之前写的线稿算法部署了一下\n\n<!--more-->\n\n# 基本效果：\n\n<body>\n\n<div class=\"form-group\" style=\"writing-mode:vertical-lr\" align=\"center\">\n    <input type=\"file\" name=\"file\" id=\"previewFile\" onchange=\"selectImage(this)\">\n\t<div style=\"display: inline-block\" align=\"center\">\n        <img src=\"https://i.loli.net/2021/04/12/wpBqePcGD8OmKxr.jpg\"  id=\"preview-image\"  style=\"width:360px;height:240px;\"/>\n        <img src=\"https://i.loli.net/2021/04/12/EZjAFvkiQNt5pCT.png\"  id=\"result-image\"  style=\"width:360px;height:240px;\"/>\n    </div>\n    <button name=\"uploadImage\" onclick=\"postData()\" >\n        <a>\n            上传\n        </a>\n    </button>\n</div>\n\n</body>\n\n<script type=\"text/javascript\">\n    var data = \"\";\n    function selectImage(file) {\n        if (!file.files || !file.files[0]) {\n            return;\n        }\n        var reader = new FileReader();\n        reader.onload = function (evt) {\n            document.getElementById('preview-image').src = evt.target.result;\n            image = evt.target.result;\n        }\n        data = file.files[0];\n        reader.readAsDataURL(file.files[0]);\n    }\n    function postData() {\n        var xmlhttp;\n        xmlhttp=new XMLHttpRequest();\n        var formData = new FormData();\n        formData.append(\"file\", data);\n        xmlhttp.open(\"POST\",basePath+\"/img\",true);\n        xmlhttp.responseType = \"blob\";\n        xmlhttp.onload = function(){\n            console.log(this);\n            if (this.status == 200) {\n                var blob = this.response;\n                var img = document.getElementById(\"result-image\");\n                img.onload = function(e) {\n                    window.URL.revokeObjectURL(img.src);\n                };\n                img.src = window.URL.createObjectURL(blob);\n            }\n        }\n        xmlhttp.send(formData);\n        }\nfunction loadImage_file(blob){\n    var fr=new FileReader();\n    fr.readAsDataURL(blob);\n    fr.onload=function(e){\n        var preview=document.getElementById('result-image');\n        preview.src=e.target.result;\n    }\n}\n//赋值变量\nvar basePath = getContextPath();\n// 获取项目路径\nfunction getContextPath() {\n    return \"https://service.umb.ink/art/\"\n}\n\n</script>\n\n# 请求体\n\n请求URL：https://service.umb.ink/art/img\n\nMethod :   POST\n\nRequestForm: 将img作为data放在FormData中进行请求\n\n```json\n{\n\t\"file\": fileData\n}\n```\n\n Response：处理完成后的线稿图像为二进制流PNG图片\n\n# 示例\n\n```javascript\nfunction postData() {\n        var xmlhttp;\n        xmlhttp=new XMLHttpRequest();\n        var formData = new FormData();\n        formData.append(\"file\", data);\n        xmlhttp.open(\"POST\",basePath+\"/img\",true); // 请求图片\n        xmlhttp.responseType = \"blob\";\n        xmlhttp.onload = function(){\n            console.log(this);\n            if (this.status == 200) {\n                var blob = this.response;\n                var img = document.getElementById(\"result-image\"); // 渲染到img标签\n                img.onload = function(e) {\n                    window.URL.revokeObjectURL(img.src);\n                };\n                img.src = window.URL.createObjectURL(blob);\n            }\n        }\n        xmlhttp.send(formData);\n\n    }\n    //赋值变量\n    var basePath = getContextPath();\n    // 获取项目路径\n    function getContextPath() {\n        return \"http://101.34.24.60:8008\"\n    }\n```\n\n","tags":["API"]},{"title":"gitalk 403、Error_Validation_Failed以及Network Error问题解决","url":"/2021/10/19/gitalk-403以及Error-Validation-Failed问题解决/","content":"\n# 问题起源\n\n在配置gitalk评论后，会出现403报错、Netword Error和Error_Validation_Failed等问题而导致gitalk无法正常使用,这些问题多半都是因为**缺乏gitalk代理**导致的\n\n<!--more-->\n\n![](https://i.loli.net/2021/10/21/9fRcw8ajYz4WMTU.png)\n\n# 查找解决办法\n\n先前往gitalk的github仓库看有没有人提issues，一番搜寻后发现确实有不少人有这个问题，而且已经给出了可能的原因\n\n![](https://i.loli.net/2021/10/21/NUlaYjnCmKt2J3S.png)\n\n前往博客查看接口响应情况\n\n![](https://i.loli.net/2021/10/21/YiNMa5j2KdnHqAB.png)\n\n确实如issues所说，国内无法正常访问github的access_token，按照issues提供的解决办法，来挂个代理试试\n\n通过和[某位朋友](https://rainchan.win/)线下py,拿到了他自己搭建的一个代理地址\n\n> 或者可以去别的网站打开F12寻找他们的access_token代理地址，比如[gitalk的官方网站](https://gitalk.github.io/)\n>\n> ![](https://i.loli.net/2021/10/21/HRJPQ8Ntix2EdFV.png)\n\n然后去hexo主题源目录下找到gitalk的源文件（各个主题的文件路径可能不同，但是总可以找到的）\n\n![](https://i.loli.net/2021/10/21/YFdWOxbtJple472.png)\n\n修改gitalk对象构造器里的**proxy字段**（如果没有可以自己加一个）\n\n最后编译，部署，问题便解决了\n\n如果部署上去依然报错，那么多半是代理挂掉了，可以试试更换一个代理\n\n","tags":["踩坑","blog"]},{"title":"基于gitalk搭建博客评论","url":"/2021/10/19/基于gitalk搭建博客评论/","content":"\n# 起因\n\n搭建好了个人博客，为了能够与沙雕网友在博客里愉快吹逼，需要开一个评论\n\n<!--more-->\n\n# 步骤\n\n这里选用使用人数最多的[gitalk](https://github.com/gitalk/gitalk)\n\n## 1. npm安装\n\n```bash\nnpm i --save gitalk\n```\n\n## 2. 创建Github Application\n\n创建一个GithubApplication，可以[点这里创建](https://github.com/settings/applications/new)\n\n![](https://i.loli.net/2021/10/21/E13woviRhL8cdSH.png)\n\n> **字段说明**：\n>\n> ​\tApplication name：应用名称,叫啥都行，可以叫BlogTalk方便区分\n>\n> ​\tHomepage URL：你的博客的链接，如果没有配域名的话就是https://\\<githubname>.github.io\n>\n> ​\tApplication description: 应用描述，随便写\n>\n> ​\tAuthorization callback URL:  验证回调地址，同HomePageURL\n\n## 3. 查看clientID和clientSecret\n\n到Github首页，点击个人头像->settings->Developer settings->OAuth Apps->刚才创建的应用\n\n![](https://i.loli.net/2021/10/21/bBEZzhP5TvHpaxo.png)\n\n![](https://i.loli.net/2021/10/21/StJjKEZe4DcmU7Q.png)\n\n如图就是ClientID，点击Generate a new client secret可查看Client secrets\n\n![](https://i.loli.net/2021/10/21/32ZzMywVvlUcXQ9.png)\n\n## 4. 创建一个github仓库用来存储评论\n\n随便新建一个仓库，注意设为Public即可\n\n## 5. 配置\n\n![](https://i.loli.net/2021/10/21/EjRYfImGpcwPdug.png)\n\n找到博客主体的配置文件中关于gitalk的配置（如果博客没有可以参考[官方文档](https://github.com/gitalk/gitalk)，自己魔改一番）（如果不想改，建议换主题）\n\n由此，gitalk便配置完成了，编译部署之后即可查看效果\n\n# 番外：配置代理\n\n在某些情况下可能会出现gitalk无法正常工作，报403、Netword Error等情况，这些情况只需要配置一个代理即可，解决方法可以参考[另一篇文章](https://farewell12345.github.io/2021/10/19/gitalk-403%E4%BB%A5%E5%8F%8AError-Validation-Failed%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/)\n\n","tags":["blog"]},{"title":"Hexo + github Page 快速搭建个人博客","url":"/2021/04/12/hexo-github-page-快速搭建个人博客/","content":"\n使用Hexo+Github Page快速搭建个人博客 \n\n<!--more-->\n\n**注意：本博客仅仅针对纯小白，快速搭建一个能用的博客**\n\n# 环境搭建\n\n1. 安装[NodeJS](http://nodejs.cn/learn/how-to-install-nodejs)(建议使用 Node.js 12.0 及以上版本)\n\n2. 安装[Git](https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496)（参考廖雪峰git教程）\n\n3. 注册一个Github账号\n\n4. 登录Github\n\n5. 在GitHub上新建一个仓库\n\n   ![](https://i.loli.net/2021/04/12/altbZHiUjze6r73.png)\n\n   > 如图，点击**New repository**，在**Repository name** 的位置填写域名，格式是 **username.github.io**.\n   >\n   > 比如你的github名字是farewell12345，那么这里就写farewell12345.github.io\n\n   <img src=\"https://i.loli.net/2021/04/12/TB6rNASgf49kPIy.png\" style=\"zoom:67%;\" />\n\n   > 填完以后可以啥都不用选，拉到最下面**点击Create repository**\n   >\n   > 创建成功之后，进入仓库，点击右上角的 Settings\n\n   ![](https://i.loli.net/2021/04/12/FJ9Dl2BVkEdSKMu.png)\n\n   > 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题\n\n   ![img](https://cdn.sspai.com/20190506142607.jpg)\n\n   > 主题随便选一个，选择完毕后在跳转界面点击Commit changes，就完成了Github Page的配置\n   >\n   > 这时可以试着访问一下 **https://username.github.io**   （就是刚才在**Repository name** 的位置填写的域名），如果正常打开了页面，就说明配置成功了。\n\n6. > **选择一个空文件夹**，打开Bash窗口（装好Git以后右键菜单中自带），使用npm安装Hexo\n\n   ```bash\n   npm install hexo-cli -g\n   ```\n\n   > 安装完成后依次执行下列命令\n\n   ```bash\n   hexo init Blog\n   cd Blog\n   npm install\n   hexo g\n   hexo s\n   ```\n\n   > hexo s输入完毕后，不要关闭Bash窗口,就保持这样的状态，然后进入浏览器，输入http://localhost:4000，去尝试访问这个地址，如果访问到了页面，说明本地Hexo 环境已经搭建好了\n\n   ![](https://i.loli.net/2021/04/12/khg9cIexFs4X6a7.png)\n\n# 开始搭建属于自己的博客\n\n> 到[Hexo主题网站（点击蓝字即可）](https://hexo.io/themes/index.html)找一个你最顺眼的主题，点进去，找到它的使用手册，因为不同的主题其说明文档也不一样，所以在配置主题的过程中就需要自己去踩坑了。这里以我目前在用的[Nexmoe主题](https://github.com/theme-nexmoe/hexo-theme-nexmoe)为例：\n>\n> 从Hexo主题网站找到它以后，点击进入它的Github仓库，点击Code，然后download zip（如果配置了Git SSH Key可以选择直接clone），下载主题。\n\n![](https://i.loli.net/2021/04/12/UoNKeZAJabO1E8Y.png)\n\n> 打开你电脑上之前用Hexo生成的Blog文件夹,进入themes文件夹中，把刚才下载好的主题zip**解压并放入这个themes文件夹下**\n\n![](https://i.loli.net/2021/04/12/9SWjfnUIdHOK1Xb.png)\n\n​\t\t\t![](https://i.loli.net/2021/04/12/NaRAJjgOYZemrPT.png)\n\n> 打开blog目录下的config.yml配置文件，修改theme为主题文件夹的名字，比如：\n\n![](https://i.loli.net/2021/04/12/alC1nNsSvrdEwxp.png)\n\n> 在config.yml中修改博客名和描述等信息\n\n![](https://i.loli.net/2021/04/12/YUftQ2PCTZ53NBw.png)\n\n![](https://i.loli.net/2021/04/12/CN4upV1bPYU8Dqy.png)\n\n> author:作者\n>\n> title：你博客标题（名字）\n>\n> description：博客描述\n>\n> url：设置你博客的域名（就刚才在Github上设置的那个）\n>\n> config基础设置这样就可以了，其他如果想了解的话可以去[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\n> **返回主题仓库查看Readme**\n\n![](https://i.loli.net/2021/04/12/JT42NABOcyjuQlH.png)\n\n> 查看主题的教程，对主题进行自定义配置\n>\n> 打开主题文件夹\n\n![](https://i.loli.net/2021/04/12/EYSJrR94QegWm8A.png)\n\n打开这个目录下的config.yml，对照主题官方文档进行自定义配置\n\n（因为每个人选择的主题不一样，所以这里就不多赘述了，一般主题的官方文档是写得很详细的）\n\n### 运行博客\n\n在Blog根目录下运行Bash窗口，输入\n\n```bash\nhexo g\nhexo s\n```\n\n访问http://localhost:4000就可以看到自己配置出的博客了（如果步骤没有错误的话）\n\n输入\n\n```bash\nhexo s --debug\n```\n\n可以进入debug模式，可以看到博客的运行日志\n\n### 部署博客\n\n进入Blog目录下的public文件夹，打开Bash窗口，依次输入以下命令：\n\n```bash\ngit init\ngit remote add origin  <你的博客在github上的链接>\ngit add .\ngit commit -m \"提交的描述\"\ngit push origin master\n```\n\n这里需要获取**你的博客在github上的链接**，打开博客对应的github仓库，点击code，\n\n![](https://i.loli.net/2021/04/12/Pdqr9t3ZfGAo6TC.png)\n\n这个就是仓库的链接\n\npush成功以后，等一会去查看github仓库是否有了我们push上去的东西，如果有，那就可以去试着访问https://username.github.io（就是刚才在**Repository name** 的位置填写的域名）了，如果出现了界面，那就说明博客成功了\n\n![](https://i.loli.net/2021/10/11/b5Yqy8RLKEJpz6U.png)\n\n<h4>如果配置的过程中遇到未知错误，请记住搜索引擎是个好东西（</h4>\n\n","tags":["blog","Hexo"]},{"title":"边缘提取---图片转线稿","url":"/2021/04/12/边缘提取-图片转线稿/","content":"\n\n\n\n\n一种提取图片边缘的算法\n\n<!--more-->\n\n# 起源\n\n突发奇想利用边缘提取做了一个图片转线稿的小程序\n\n先来看一下效果：\n\n<img src=\"https://i.loli.net/2021/10/11/e9G2JMzf1ilEcKB.png\" style=\"zoom: 50%;\" />\n\n\n\n# 环境\n\nPython 3.8 、PIL、numpy\n\n直接使用pip install 安装即可\n\n```python\npip install pillow\npip install numpy\n```\n\n# 思路\n\n众所周知，我们所看到的图片是一副二维图片，由一堆RGB色值各不相同的像素点构成。\n\n那么我们可以将各个像素点的**RGB色值转变为图片的第三维度**，这样图片就由二维平面图变为了三维立体图。\n\n此时我们将这张图片**看作一个实实在在的三维物体**，三维物体表面某点高度由对应二维平面的像素点的RGB色值决定，RGB色值有大有小，自然三维物体**表面就会有高低起伏**。\n\n在某个高度，某个方向上**添加一个点光源照射这个物体**，在光的照射下，物体凹凸不平的表面自然而然就会出现阴影（RGB色值变化越大的地方表面越陡，阴影越深），再**将这些阴影投影回二维平面**，这样就得到了图片的边缘。\n\n# 实现\n\n\n\n1. #### 将原图转为灰度图\n\n   为了简化矩阵，提高运算速度，我们对图像进行灰度图转换\n\n2. #### 使用高斯滤波进行降噪\n\n   这个算法对噪点很敏感（你想想平地上突然隆起一个笔直的擎天柱是不是显得特别扎眼）去除噪点影响，方法为使用高斯滤波，使图像模糊，然后使用领域降噪对图像进行降噪处理\n\n3. #### 计算图像梯度\n\n   numpy自带矩阵梯度计算(np.gradient)，该梯度用来作为图像升维参考，梯度值越大，说明图像颜色在该点变化率越大，对应的虚拟深度应该也越大。\n\n4. #### 赋予图像虚拟深度\n\n   因为图像中的RGB值有大有小，直接作为三维高度并不合适，需要经过一些权衡计算来将其转变为三维高度，我们这里结合图像梯度和颜色向量来计算，并预设一个放大深度值，用来放大深度效果。\n\n5. #### 光源设置\n\n   这个需要进行调参了，光源的位置是一个很玄学的问题，位置不同，最后的效果也完全不一样。\n\n   个人觉得光源的最佳位置是与平面俯视角（即z轴与平面的夹角）呈 α =（pi / 2.2 ）°，平面方向角（即x与y的夹角呈β =（pi / 4 ）°，这个角度下提取到的线稿最为清晰。\n\n6. #### 三维梯度转二维灰度\n\n   最后我们需要的是二维矩阵而不是三维矩阵，因此分别求平面各点在xy平面、xz平面、yz平面的投影\n   $$\n   D_{x},D_{y},D_{z}\n   $$\n   将三个方向的投影的值相加的和与原色相乘，也就是（灰度化）\n   $$\n   (D_{x}+D_{y}+D_{z})*255\n   $$\n   \n7. #### 极值处理\n\n   将处理后的图像进行极值处理，RGB值靠近黑色（0）的归为黑色，靠近白色（255）的归为白色，突出边缘。\n\n8. #### 锐化处理\n\n   为了让我们最后的线稿更加清晰，可以对处理后的图片进行一定程度的锐化操作\n\n   # 代码\n\n```python\n# 领域降噪\ndef calculate_noise_count(img_obj, w, h, width, height):\n    count = 0\n    for _w_ in [w - 1, w, w + 1]:\n        for _h_ in [h - 1, h, h + 1]:\n            if _w_ > width - 1:\n                continue\n            if _h_ > height - 1:\n                continue\n            if _w_ == w and _h_ == h:\n                continue\n            if img_obj[_w_, _h_] < 230:  # 这里因为是灰度图像，设置小于230为非白色\n                count += 1\n    return count\n\n\n# 高斯滤波+锐化+领域降噪的线稿提取方案\ndef img_ege_get(byte: bytes):\n    time = datetime.now()\n    byte_stream = io.BytesIO(byte)\n    im1 = Image.open(byte_stream).convert('L') # 灰度图\n    im = im1.filter(ImageFilter.GaussianBlur(radius=0.75)) # 高斯模糊 75%\n\n    a = np.asarray(im).astype('float')\n\n    depth = 10. # 设定虚拟深度\n    grad = np.gradient(a)\n    grad_x, grad_y = grad\n    grad_x = grad_x * depth / 100.\n    grad_y = grad_y * depth / 100.\n    # 梯度向量计算\n    A = np.sqrt(grad_x ** 2 + grad_y ** 2 + 1.)\n    uni_x = grad_x / A\n    uni_y = grad_y / A\n    uni_z = 1. / A\n    vec_el = np.pi / 2.2\n    vec_az = np.pi / 4.\n    dx = np.cos(vec_el) * np.cos(vec_az)\n    dy = np.cos(vec_el) * np.sin(vec_az)\n    dz = np.sin(vec_el)\n\n    b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z)\n    b = b.clip(0, 255)  # 二值化处理，要么为0，（黑色边缘）要么为255（白色背景）\n    im2 = Image.fromarray(b.astype('uint8'))\n    im2 = im2.filter(ImageFilter.SHARPEN)\n    weight, height = im2.size\n    # 降噪\n    pim = im2.load()\n    map(row_noise, [(pim, height, weight, w,) for w in range(weight)])\n    imgByteArray = io.BytesIO()\n    im2.save(imgByteArray, format='png')\n    imgByteArray = imgByteArray.getvalue()\n    print(datetime.now() - time)\n    return imgByteArray\n\n# 领域降噪\ndef row_noise(pim, height, weight, w):\n    for h in range(height):\n        if calculate_noise_count(pim, w, h, weight, height) < 4:\n            pim[w, h] = 255\n```\n\n# [源码地址](https://github.com/farewell12345/FAQ-Bot-QQ/tree/master/src/main/Python)","tags":["python","机器学习"]}]