[{"title":"LineArt-线稿API使用文档","url":"/2022/04/01/LineArt-线稿API使用文档/","content":"\n\n\n\n\n将之前写的线稿算法部署了一下\n\n<!--more-->\n\n# 基本效果：\n\n<body>\n\n<div class=\"form-group\" style=\"writing-mode:vertical-lr\" align=\"center\">\n    <input type=\"file\" name=\"file\" id=\"previewFile\" onchange=\"selectImage(this)\">\n    <div style=\"display: inline-block\" align=\"center\">\n        <img src=\"\"  id=\"preview-image\"  style=\"width:360px;height:240px;\"/>\n        <img src=\"\"  id=\"result-image\"  style=\"width:360px;height:240px;\"/>\n    </div>\n    <button name=\"uploadImage\" onclick=\"postData()\" >\n        <a>\n            上传\n        </a>\n    </button>\n</div>\n</body>\n\n<script type=\"text/javascript\">\n    var data = \"\";\n    function selectImage(file) {\n        if (!file.files || !file.files[0]) {\n            return;\n        }\n        var reader = new FileReader();\n        reader.onload = function (evt) {\n            document.getElementById('preview-image').src = evt.target.result;\n            image = evt.target.result;\n        }\n        data = file.files[0];\n        reader.readAsDataURL(file.files[0]);\n    }\n    function postData() {\n        var xmlhttp;\n        xmlhttp=new XMLHttpRequest();\n        var formData = new FormData();\n        formData.append(\"file\", data);\n        xmlhttp.open(\"POST\",basePath+\"/img\",true);\n        xmlhttp.responseType = \"blob\";\n        xmlhttp.onload = function(){\n            console.log(this);\n            if (this.status == 200) {\n                var blob = this.response;\n                var img = document.getElementById(\"result-image\");\n                img.onload = function(e) {\n                    window.URL.revokeObjectURL(img.src);\n                };\n                img.src = window.URL.createObjectURL(blob);\n            }\n        }\n        xmlhttp.send(formData);\n        }\nfunction loadImage_file(blob){\n    var fr=new FileReader();\n    fr.readAsDataURL(blob);\n    fr.onload=function(e){\n        var preview=document.getElementById('result-image');\n        preview.src=e.target.result;\n    }\n}\n//赋值变量\nvar basePath = getContextPath();\n// 获取项目路径\nfunction getContextPath() {\n    return \"https://service.umb.ink/art/\"\n}\n\n</script>\n\n# 请求体\n\n请求URL：https://service.umb.ink/art/img\n\nMethod :   POST\n\nRequestForm: 将img作为data放在FormData中进行请求\n\n```json\n{\n\t\"file\": fileData\n}\n```\n\n Response：处理完成后的线稿图像为二进制流PNG图片\n\n# 示例\n\n```javascript\nfunction postData() {\n        var xmlhttp;\n        xmlhttp=new XMLHttpRequest();\n        var formData = new FormData();\n        formData.append(\"file\", data);\n        xmlhttp.open(\"POST\",basePath+\"/img\",true); // 请求图片\n        xmlhttp.responseType = \"blob\";\n        xmlhttp.onload = function(){\n            console.log(this);\n            if (this.status == 200) {\n                var blob = this.response;\n                var img = document.getElementById(\"result-image\"); // 渲染到img标签\n                img.onload = function(e) {\n                    window.URL.revokeObjectURL(img.src);\n                };\n                img.src = window.URL.createObjectURL(blob);\n            }\n        }\n        xmlhttp.send(formData);\n\n    }\n    //赋值变量\n    var basePath = getContextPath();\n    // 获取项目路径\n    function getContextPath() {\n        return \"http://101.34.24.60:8008\"\n    }\n```\n\n","tags":["API"]},{"title":"gitalk 403、Error_Validation_Failed以及Network Error问题解决","url":"/2021/10/19/gitalk-403以及Error-Validation-Failed问题解决/","content":"\n# 问题起源\n\n在配置gitalk评论后，会出现403报错、Netword Error和Error_Validation_Failed等问题而导致gitalk无法正常使用,这些问题多半都是因为**缺乏gitalk代理**导致的\n\n<!--more-->\n\n![](https://i.loli.net/2021/10/21/9fRcw8ajYz4WMTU.png)\n\n# 查找解决办法\n\n先前往gitalk的github仓库看有没有人提issues，一番搜寻后发现确实有不少人有这个问题，而且已经给出了可能的原因\n\n![](https://i.loli.net/2021/10/21/NUlaYjnCmKt2J3S.png)\n\n前往博客查看接口响应情况\n\n![](https://i.loli.net/2021/10/21/YiNMa5j2KdnHqAB.png)\n\n确实如issues所说，国内无法正常访问github的access_token，按照issues提供的解决办法，来挂个代理试试\n\n通过和[某位朋友](https://rainchan.win/)线下py,拿到了他自己搭建的一个代理地址\n\n> 或者可以去别的网站打开F12寻找他们的access_token代理地址，比如[gitalk的官方网站](https://gitalk.github.io/)\n>\n> ![](https://i.loli.net/2021/10/21/HRJPQ8Ntix2EdFV.png)\n\n然后去hexo主题源目录下找到gitalk的源文件（各个主题的文件路径可能不同，但是总可以找到的）\n\n![](https://i.loli.net/2021/10/21/YFdWOxbtJple472.png)\n\n修改gitalk对象构造器里的**proxy字段**（如果没有可以自己加一个）\n\n最后编译，部署，问题便解决了\n\n如果部署上去依然报错，那么多半是代理挂掉了，可以试试更换一个代理\n\n","tags":["踩坑","blog"]},{"title":"基于gitalk搭建博客评论","url":"/2021/10/19/基于gitalk搭建博客评论/","content":"\n# 起因\n\n搭建好了个人博客，为了能够与沙雕网友在博客里愉快吹逼，需要开一个评论\n\n<!--more-->\n\n# 步骤\n\n这里选用使用人数最多的[gitalk](https://github.com/gitalk/gitalk)\n\n## 1. npm安装\n\n```bash\nnpm i --save gitalk\n```\n\n## 2. 创建Github Application\n\n创建一个GithubApplication，可以[点这里创建](https://github.com/settings/applications/new)\n\n![](https://i.loli.net/2021/10/21/E13woviRhL8cdSH.png)\n\n> **字段说明**：\n>\n> ​\tApplication name：应用名称,叫啥都行，可以叫BlogTalk方便区分\n>\n> ​\tHomepage URL：你的博客的链接，如果没有配域名的话就是https://\\<githubname>.github.io\n>\n> ​\tApplication description: 应用描述，随便写\n>\n> ​\tAuthorization callback URL:  验证回调地址，同HomePageURL\n\n## 3. 查看clientID和clientSecret\n\n到Github首页，点击个人头像->settings->Developer settings->OAuth Apps->刚才创建的应用\n\n![](https://i.loli.net/2021/10/21/bBEZzhP5TvHpaxo.png)\n\n![](https://i.loli.net/2021/10/21/StJjKEZe4DcmU7Q.png)\n\n如图就是ClientID，点击Generate a new client secret可查看Client secrets\n\n![](https://i.loli.net/2021/10/21/32ZzMywVvlUcXQ9.png)\n\n## 4. 创建一个github仓库用来存储评论\n\n随便新建一个仓库，注意设为Public即可\n\n## 5. 配置\n\n![](https://i.loli.net/2021/10/21/EjRYfImGpcwPdug.png)\n\n找到博客主体的配置文件中关于gitalk的配置（如果博客没有可以参考[官方文档](https://github.com/gitalk/gitalk)，自己魔改一番）（如果不想改，建议换主题）\n\n由此，gitalk便配置完成了，编译部署之后即可查看效果\n\n# 番外：配置代理\n\n在某些情况下可能会出现gitalk无法正常工作，报403、Netword Error等情况，这些情况只需要配置一个代理即可，解决方法可以参考[另一篇文章](https://farewell12345.github.io/2021/10/19/gitalk-403%E4%BB%A5%E5%8F%8AError-Validation-Failed%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/)\n\n","tags":["blog"]},{"title":"Hexo + github Page 快速搭建个人博客","url":"/2021/04/12/hexo-github-page-快速搭建个人博客/","content":"\n使用Hexo+Github Page快速搭建个人博客 \n\n<!--more-->\n\n**注意：本博客仅仅针对纯小白，快速搭建一个能用的博客**\n\n# 环境搭建\n\n1. 安装[NodeJS](http://nodejs.cn/learn/how-to-install-nodejs)(建议使用 Node.js 12.0 及以上版本)\n\n2. 安装[Git](https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496)（参考廖雪峰git教程）\n\n3. 注册一个Github账号\n\n4. 登录Github\n\n5. 在GitHub上新建一个仓库\n\n   ![](https://i.loli.net/2021/04/12/altbZHiUjze6r73.png)\n\n   > 如图，点击**New repository**，在**Repository name** 的位置填写域名，格式是 **username.github.io**.\n   >\n   > 比如你的github名字是farewell12345，那么这里就写farewell12345.github.io\n\n   <img src=\"https://i.loli.net/2021/04/12/TB6rNASgf49kPIy.png\" style=\"zoom:67%;\" />\n\n   > 填完以后可以啥都不用选，拉到最下面**点击Create repository**\n   >\n   > 创建成功之后，进入仓库，点击右上角的 Settings\n\n   ![](https://i.loli.net/2021/04/12/FJ9Dl2BVkEdSKMu.png)\n\n   > 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题\n\n   ![img](https://cdn.sspai.com/20190506142607.jpg)\n\n   > 主题随便选一个，选择完毕后在跳转界面点击Commit changes，就完成了Github Page的配置\n   >\n   > 这时可以试着访问一下 **https://username.github.io**   （就是刚才在**Repository name** 的位置填写的域名），如果正常打开了页面，就说明配置成功了。\n\n6. > **选择一个空文件夹**，打开Bash窗口（装好Git以后右键菜单中自带），使用npm安装Hexo\n\n   ```bash\n   npm install hexo-cli -g\n   ```\n\n   > 安装完成后依次执行下列命令\n\n   ```bash\n   hexo init Blog\n   cd Blog\n   npm install\n   hexo g\n   hexo s\n   ```\n\n   > hexo s输入完毕后，不要关闭Bash窗口,就保持这样的状态，然后进入浏览器，输入http://localhost:4000，去尝试访问这个地址，如果访问到了页面，说明本地Hexo 环境已经搭建好了\n\n   ![](https://i.loli.net/2021/04/12/khg9cIexFs4X6a7.png)\n\n# 开始搭建属于自己的博客\n\n> 到[Hexo主题网站（点击蓝字即可）](https://hexo.io/themes/index.html)找一个你最顺眼的主题，点进去，找到它的使用手册，因为不同的主题其说明文档也不一样，所以在配置主题的过程中就需要自己去踩坑了。这里以我目前在用的[Nexmoe主题](https://github.com/theme-nexmoe/hexo-theme-nexmoe)为例：\n>\n> 从Hexo主题网站找到它以后，点击进入它的Github仓库，点击Code，然后download zip（如果配置了Git SSH Key可以选择直接clone），下载主题。\n\n![](https://i.loli.net/2021/04/12/UoNKeZAJabO1E8Y.png)\n\n> 打开你电脑上之前用Hexo生成的Blog文件夹,进入themes文件夹中，把刚才下载好的主题zip**解压并放入这个themes文件夹下**\n\n![](https://i.loli.net/2021/04/12/9SWjfnUIdHOK1Xb.png)\n\n​\t\t\t![](https://i.loli.net/2021/04/12/NaRAJjgOYZemrPT.png)\n\n> 打开blog目录下的config.yml配置文件，修改theme为主题文件夹的名字，比如：\n\n![](https://i.loli.net/2021/04/12/alC1nNsSvrdEwxp.png)\n\n> 在config.yml中修改博客名和描述等信息\n\n![](https://i.loli.net/2021/04/12/YUftQ2PCTZ53NBw.png)\n\n![](https://i.loli.net/2021/04/12/CN4upV1bPYU8Dqy.png)\n\n> author:作者\n>\n> title：你博客标题（名字）\n>\n> description：博客描述\n>\n> url：设置你博客的域名（就刚才在Github上设置的那个）\n>\n> config基础设置这样就可以了，其他如果想了解的话可以去[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\n> **返回主题仓库查看Readme**\n\n![](https://i.loli.net/2021/04/12/JT42NABOcyjuQlH.png)\n\n> 查看主题的教程，对主题进行自定义配置\n>\n> 打开主题文件夹\n\n![](https://i.loli.net/2021/04/12/EYSJrR94QegWm8A.png)\n\n打开这个目录下的config.yml，对照主题官方文档进行自定义配置\n\n（因为每个人选择的主题不一样，所以这里就不多赘述了，一般主题的官方文档是写得很详细的）\n\n### 运行博客\n\n在Blog根目录下运行Bash窗口，输入\n\n```bash\nhexo g\nhexo s\n```\n\n访问http://localhost:4000就可以看到自己配置出的博客了（如果步骤没有错误的话）\n\n输入\n\n```bash\nhexo s --debug\n```\n\n可以进入debug模式，可以看到博客的运行日志\n\n### 部署博客\n\n进入Blog目录下的public文件夹，打开Bash窗口，依次输入以下命令：\n\n```bash\ngit init\ngit remote add origin  <你的博客在github上的链接>\ngit add .\ngit commit -m \"提交的描述\"\ngit push origin master\n```\n\n这里需要获取**你的博客在github上的链接**，打开博客对应的github仓库，点击code，\n\n![](https://i.loli.net/2021/04/12/Pdqr9t3ZfGAo6TC.png)\n\n这个就是仓库的链接\n\npush成功以后，等一会去查看github仓库是否有了我们push上去的东西，如果有，那就可以去试着访问https://username.github.io（就是刚才在**Repository name** 的位置填写的域名）了，如果出现了界面，那就说明博客成功了\n\n![](https://i.loli.net/2021/10/11/b5Yqy8RLKEJpz6U.png)\n\n<h4>如果配置的过程中遇到未知错误，请记住搜索引擎是个好东西（</h4>\n\n","tags":["blog","Hexo"]},{"title":"边缘提取---图片转线稿","url":"/2021/04/12/边缘提取-图片转线稿/","content":"\n\n\n\n\n一种提取图片边缘的算法\n\n<!--more-->\n\n# 起源\n\n突发奇想利用边缘提取做了一个图片转线稿的小程序\n\n先来看一下效果：\n\n<img src=\"https://i.loli.net/2021/10/11/e9G2JMzf1ilEcKB.png\" style=\"zoom: 50%;\" />\n\n\n\n# 环境\n\nPython 3.8 、PIL、numpy\n\n直接使用pip install 安装即可\n\n```python\npip install pillow\npip install numpy\n```\n\n# 思路\n\n众所周知，我们所看到的图片是一副二维图片，由一堆RGB色值各不相同的像素点构成。\n\n那么我们可以将各个像素点的**RGB色值转变为图片的第三维度**，这样图片就由二维平面图变为了三维立体图。\n\n此时我们将这张图片**看作一个实实在在的三维物体**，三维物体表面某点高度由对应二维平面的像素点的RGB色值决定，RGB色值有大有小，自然三维物体**表面就会有高低起伏**。\n\n在某个高度，某个方向上**添加一个点光源照射这个物体**，在光的照射下，物体凹凸不平的表面自然而然就会出现阴影（RGB色值变化越大的地方表面越陡，阴影越深），再**将这些阴影投影回二维平面**，这样就得到了图片的边缘。\n\n# 实现\n\n\n\n1. #### 将原图转为灰度图\n\n   为了简化矩阵，提高运算速度，我们对图像进行灰度图转换\n\n2. #### 使用高斯滤波进行降噪\n\n   这个算法对噪点很敏感（你想想平地上突然隆起一个笔直的擎天柱是不是显得特别扎眼）去除噪点影响，方法为使用高斯滤波，使图像模糊，然后使用领域降噪对图像进行降噪处理\n\n3. #### 计算图像梯度\n\n   numpy自带矩阵梯度计算(np.gradient)，该梯度用来作为图像升维参考，梯度值越大，说明图像颜色在该点变化率越大，对应的虚拟深度应该也越大。\n\n4. #### 赋予图像虚拟深度\n\n   因为图像中的RGB值有大有小，直接作为三维高度并不合适，需要经过一些权衡计算来将其转变为三维高度，我们这里结合图像梯度和颜色向量来计算，并预设一个放大深度值，用来放大深度效果。\n\n5. #### 光源设置\n\n   这个需要进行调参了，光源的位置是一个很玄学的问题，位置不同，最后的效果也完全不一样。\n\n   个人觉得光源的最佳位置是与平面俯视角（即z轴与平面的夹角）呈 α =（pi / 2.2 ）°，平面方向角（即x与y的夹角呈β =（pi / 4 ）°，这个角度下提取到的线稿最为清晰。\n\n6. #### 三维梯度转二维灰度\n\n   最后我们需要的是二维矩阵而不是三维矩阵，因此分别求平面各点在xy平面、xz平面、yz平面的投影\n   $$\n   D_{x},D_{y},D_{z}\n   $$\n   将三个方向的投影的值相加的和与原色相乘，也就是（灰度化）\n   $$\n   (D_{x}+D_{y}+D_{z})*255\n   $$\n   \n7. #### 极值处理\n\n   将处理后的图像进行极值处理，RGB值靠近黑色（0）的归为黑色，靠近白色（255）的归为白色，突出边缘。\n\n8. #### 锐化处理\n\n   为了让我们最后的线稿更加清晰，可以对处理后的图片进行一定程度的锐化操作\n\n   # 代码\n\n```python\n# 领域降噪\ndef calculate_noise_count(img_obj, w, h, width, height):\n    count = 0\n    for _w_ in [w - 1, w, w + 1]:\n        for _h_ in [h - 1, h, h + 1]:\n            if _w_ > width - 1:\n                continue\n            if _h_ > height - 1:\n                continue\n            if _w_ == w and _h_ == h:\n                continue\n            if img_obj[_w_, _h_] < 230:  # 这里因为是灰度图像，设置小于230为非白色\n                count += 1\n    return count\n\n\n# 高斯滤波+锐化+领域降噪的线稿提取方案\ndef img_ege_get(byte: bytes):\n    time = datetime.now()\n    byte_stream = io.BytesIO(byte)\n    im1 = Image.open(byte_stream).convert('L') # 灰度图\n    im = im1.filter(ImageFilter.GaussianBlur(radius=0.75)) # 高斯模糊 75%\n\n    a = np.asarray(im).astype('float')\n\n    depth = 10. # 设定虚拟深度\n    grad = np.gradient(a)\n    grad_x, grad_y = grad\n    grad_x = grad_x * depth / 100.\n    grad_y = grad_y * depth / 100.\n    # 梯度向量计算\n    A = np.sqrt(grad_x ** 2 + grad_y ** 2 + 1.)\n    uni_x = grad_x / A\n    uni_y = grad_y / A\n    uni_z = 1. / A\n    vec_el = np.pi / 2.2\n    vec_az = np.pi / 4.\n    dx = np.cos(vec_el) * np.cos(vec_az)\n    dy = np.cos(vec_el) * np.sin(vec_az)\n    dz = np.sin(vec_el)\n\n    b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z)\n    b = b.clip(0, 255)  # 二值化处理，要么为0，（黑色边缘）要么为255（白色背景）\n    im2 = Image.fromarray(b.astype('uint8'))\n    im2 = im2.filter(ImageFilter.SHARPEN)\n    weight, height = im2.size\n    # 降噪\n    pim = im2.load()\n    map(row_noise, [(pim, height, weight, w,) for w in range(weight)])\n    imgByteArray = io.BytesIO()\n    im2.save(imgByteArray, format='png')\n    imgByteArray = imgByteArray.getvalue()\n    print(datetime.now() - time)\n    return imgByteArray\n\n# 领域降噪\ndef row_noise(pim, height, weight, w):\n    for h in range(height):\n        if calculate_noise_count(pim, w, h, weight, height) < 4:\n            pim[w, h] = 255\n```\n\n# [源码地址](https://github.com/farewell12345/FAQ-Bot-QQ/tree/master/src/main/Python)","tags":["python","机器学习"]}]